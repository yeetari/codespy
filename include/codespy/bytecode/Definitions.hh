#pragma once

#include <codespy/support/Enum.hh>
#include <codespy/support/StringView.hh>
#include <codespy/support/Variant.hh>

#include <cstdint>

namespace codespy::bc {

enum class AccessFlags : std::uint16_t {
    Public = 1u << 0u,
    Private = 1u << 1u,
    Protected = 1u << 2u,
    Static = 1u << 3u,

    /// No subclasses allowed.
    Final = 1u << 4u,

    /// Treat superclass methods specially when invoked by invokespecial.
    Super = 1u << 5u,

    Interface = 1u << 9u,

    /// Declared abstract; must not be instantiated.
    Abstract = 1u << 10u,

    /// Declared synthetic; not present in source; generated by the compiler.
    Synthetic = 1u << 12u,

    /// Declared as an annotation interface.
    Annotation = 1u << 13u,

    /// Declared as an enum class.
    Enum = 1u << 14u,

    /// Is a module, not a class or interface.
    Module = 1u << 15u,
};

enum class BaseType {
    Int = 0,
    Long,
    Float,
    Double,
    Reference,
    Void,
};

enum class ConstantKind : std::uint8_t {
    Utf8 = 1,
    Integer = 3,
    Float = 4,
    Long = 5,
    Double = 6,
    Class = 7,
    String = 8,
    FieldRef = 9,
    MethodRef = 10,
    InterfaceMethodRef = 11,
    NameAndType = 12,
    MethodHandle = 15,
    Dynamic = 17,
    InvokeDynamic = 18,
};

enum class InvokeKind {
    Special,
    Static,
    Virtual,
};

enum class StackOp {
    Pop,
    Pop2,
    Dup,
    DupX1,
    DupX2,
    Dup2,
    Dup2X1,
    Dup2X2,
    Swap,
};

enum class CompareOp {
    Equal,
    NotEqual,
    LessThan,
    GreaterEqual,
    GreaterThan,
    LessEqual,
};

using Constant = Variant<std::int32_t, std::int64_t, float, double, StringView>;

enum class Opcode : std::uint8_t {
    // Constants
    ACONST_NULL = 1,
    ICONST_M1 = 2,
    ICONST_5 = 8,
    LCONST_0 = 9,
    LCONST_1 = 10,
    FCONST_0 = 11,
    FCONST_1 = 12,
    FCONST_2 = 13,
    DCONST_0 = 14,
    DCONST_1 = 15,
    BIPUSH = 16,
    SIPUSH = 17,
    LDC = 18,
    LDC_W = 19,
    LDC2_W = 20,

    // Loads
    ILOAD = 21,
    ALOAD = 25,
    ILOAD_0 = 26,
    ALOAD_3 = 45,
    // TODO: <x>aload

    // Stores
    ISTORE = 54,
    ASTORE = 58,
    ISTORE_0 = 59,
    ASTORE_3 = 78,
    // TODO: <x>astore

    // Stack
    POP = 87,
    SWAP = 95,

    // Math
    IADD = 96,
    ISUB = 100,
    IMUL = 104,
    IDIV = 108,
    IREM = 112,
    INEG = 116,

    // Casts
    I2L = 133,
    L2I = 136,
    F2I = 139,
    D2I = 142,
    I2B = 145,
    I2C = 146,
    I2S = 147,

    // Comparisons
    IFEQ = 153,
    IFLE = 158,
    IF_ICMPEQ = 159,
    IF_ICMPLE = 164,

    // Control
    IRETURN = 172,
    RETURN = 177,

    // References
    GET_STATIC = 178,
    PUT_STATIC = 179,
    GET_FIELD = 180,
    PUT_FIELD = 181,
    INVOKE_VIRTUAL = 182,
    INVOKE_SPECIAL = 183,
    INVOKE_STATIC = 184,
    INVOKE_INTERFACE = 185,
};

inline constexpr AccessFlags operator&(AccessFlags lhs, AccessFlags rhs) {
    return static_cast<AccessFlags>(codespy::to_underlying(lhs) & codespy::to_underlying(rhs));
}

inline constexpr AccessFlags operator|(AccessFlags lhs, AccessFlags rhs) {
    return static_cast<AccessFlags>(codespy::to_underlying(lhs) | codespy::to_underlying(rhs));
}

constexpr std::uint8_t operator-(Opcode lhs, Opcode rhs) {
    return codespy::to_underlying(lhs) - codespy::to_underlying(rhs);
}

constexpr auto operator<=>(Opcode lhs, Opcode rhs) {
    return codespy::to_underlying(lhs) <=> codespy::to_underlying(rhs);
}

} // namespace codespy::bc
